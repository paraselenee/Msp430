//本程序时钟采用内部RC振荡器。     DCO：8MHz,供CPU时钟;  SMCLK：1MHz,供定时器时钟
#include <msp430g2553.h>
#include <tm1638.h>  //与TM1638有关的变量及函数定义均在该H文件中

//////////////////////////////
//         常量定义         //
//////////////////////////////
#define V_T 50

// ADC10参考电压及量化单位
#define a_v 2.0
#define a_i 1.0
#define b_v -0.04
#define b_i 0.01

#define n_sample 64
//////////////////////////////
//       变量定义           //
//////////////////////////////

//	ADC10 变量定义
unsigned int sample[2]={0};//存放ADC采样结果（一次转换产生的两个结果）
unsigned int sample_v[n_sample] = {0};
unsigned int sample_i[n_sample] = {0};
unsigned int i_sample = 0;

double v_avg, i_avg;
double v, i;
int display;

// 软件定时器计数
int clock = 0;
unsigned int clock_flag = 0;

// 8位数码管显示的数字或字母符号
// 注：板上数码位从左到右序号排列为4、5、6、7、0、1、2、3
unsigned char digit[8]={' ',' ',' ',' ',' ',' ',' ',' '};

// 8位小数点 1亮  0灭
// 注：板上数码位小数点从左到右序号排列为4、5、6、7、0、1、2、3
unsigned char pnt=0x11;

// 8个LED指示灯状态，每个灯4种颜色状态，0灭，1绿，2红，3橙（红+绿）
// 注：板上指示灯从左到右序号排列为7、6、5、4、3、2、1、0
//     对应元件LED8、LED7、LED6、LED5、LED4、LED3、LED2、LED1
unsigned char led[]={0,0,0,0,0,0,0,0};

//////////////////////////////
//       系统初始化         //
//////////////////////////////

//  I/O端口和引脚初始化
void Init_Ports(void)
{
	P2SEL &= ~(BIT7+BIT6);       //P2.6、P2.7 设置为通用I/O端口
	  //因两者默认连接外晶振，故需此修改
	P2DIR |= BIT7 + BIT6 + BIT5; //P2.5、P2.6、P2.7 设置为输出
	  //本电路板中三者用于连接显示和键盘管理器TM1638，工作原理详见其DATASHEET

	P1SEL |= (BIT0+BIT1);
	P1DIR &=~ (BIT0+BIT1);
 }

//  定时器TIMER0初始化，循环定时20ms
void Init_Timer0(void)
{
	TA0CTL = TASSEL_2 + MC_1 ;      // Source: SMCLK=1MHz, UP mode,
	TA0CCR0 = 20000;                // 1MHz时钟,计满20000次为 20ms
	TA0CCTL0 = CCIE;                // TA0CCR0 interrupt enabled
}

//	ADC10初始化
void Init_ADC10()
{
  ADC10CTL1 = CONSEQ_1 + INCH_1;    // 2通道单次转换, 最大转换通道为A1
  ADC10CTL0 = ADC10SHT_2 + ADC10ON + ADC10IE + MSC;
  //采样保持时间为16 x ADC10CLKs，ADC内核开，中断使能   MSC多次转换选择开
  //参考电压选默认值VCC和VSS
  ADC10DTC1 = 0x02;
  ADC10AE0 |= BIT0+BIT1;// 使能模拟输入脚A0 A1
}

//  MCU器件初始化，注：会调用上述函数
void Init_Devices(void)
{
	WDTCTL = WDTPW + WDTHOLD;     // Stop watchdog timer，停用看门狗
	if (CALBC1_8MHZ ==0xFF || CALDCO_8MHZ == 0xFF)
	{
		while(1);            // If calibration constants erased, trap CPU!!
	}

    //设置时钟，内部RC振荡器。     DCO：8MHz,供CPU时钟;  SMCLK：1MHz,供定时器时钟
	BCSCTL1 = CALBC1_8MHZ; 	 // Set range
	DCOCTL = CALDCO_8MHZ;    // Set DCO step + modulation
	BCSCTL3 |= LFXT1S_2;     // LFXT1 = VLO
	IFG1 &= ~OFIFG;          // Clear OSCFault flag
	BCSCTL2 |= DIVS_3;       //  SMCLK = DCO/8

    Init_Ports();           //调用函数，初始化I/O口
    Init_Timer0();          //调用函数，初始化定时器0
    Init_ADC10();			//初始化ADC
    _BIS_SR(GIE);           //开全局中断

   //all peripherals are now initialized
}

//////////////////////////////
//      中断服务程序        //
//////////////////////////////

//20ms 软中断
// Timer0_A0 interrupt service routine
#pragma vector=TIMER0_A0_VECTOR
__interrupt void Timer0_A0 (void)
{
	// 0.5秒钟软定时器计数
	if(++clock >= V_T)
	{
		clock = 0;
		clock_flag = 1;
	}
}

////ADC10中断服务程序
#pragma vector=ADC10_VECTOR
__interrupt void ADC10ISR (void)
{
	sample_v[i_sample] = sample[0];
	sample_i[i_sample] = sample[1];
}

//////////////////////////////
//         主程序           //
//////////////////////////////

int main(void)
{
	Init_Devices( );
	while (clock<3);   // 延时60ms等待TM1638上电完成
	init_TM1638();	    //初始化TM1638

	while(1)
	{
		//ADC10转换
		ADC10CTL0 |= ENC + ADC10SC;
		while(ADC10CTL1 & BUSY);//等待ADC10转换完成
		ADC10SA = (unsigned int)sample;
		ADC10CTL0 &= ~ENC;

		++i_sample;

		//当采满n_sample个样本后
		if(i_sample == n_sample)
		{
			i_sample = 0;
			//计算平均值
			unsigned int sum_v = 0;
			unsigned int sum_i = 0;
			int k;
			for (k=0; k<n_sample; ++k)
			{
				sum_v += sample_v[k];
				sum_i += sample_i[k];
			}

			v_avg = 3.55*sum_v/n_sample/1024;
			//计算A1端口上的模拟输入电压
			v = a_v*v_avg + b_v;
			display = (int)(1000*v);
			digit[0] = (display/1000)%10;
			digit[1] = (display/100)%10;
			digit[2] = (display/10)%10;
			digit[3] = (display/1)%10;

			i_avg = 3.55*sum_i/n_sample/1024;
			//记录A0端口上的模拟输入电压(按照转换规则A0后被采样并传输)
			i = a_i*i_avg + b_i;
			display = (int)(1000*i);
			digit[4] = (display/1000)%10;
			digit[5] = (display/100)%10;
			digit[6] = (display/10)%10;
			digit[7] = (display/1)%10;
		}

		//每隔0.5s,刷新数码管显示
		if(clock_flag)
		{
			TM1638_RefreshDIGIandLED(digit,pnt,led);
			clock_flag = 0;
		}
	}

}
